// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/bhbosman/goLuno/internal/fmdManagerService (interfaces: IFmdManager)

// Package fmdManagerService is a generated GoMock package.
package fullMarketDataManagerService

import (
	fmt "fmt"

	errors "github.com/bhbosman/gocommon/errors"
	"golang.org/x/net/context"
)

// Interface A Comment
// Interface github.com/bhbosman/goLuno/internal/fmdManagerService
// Interface IFmdManager
// Interface IFmdManager, Method: AllInstrumentChannelName
type IFmdManagerAllInstrumentChannelNameIn struct {
}

type IFmdManagerAllInstrumentChannelNameOut struct {
	Args0 string
	Args1 error
}
type IFmdManagerAllInstrumentChannelNameError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IFmdManagerAllInstrumentChannelNameError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IFmdManagerAllInstrumentChannelName struct {
	inData         IFmdManagerAllInstrumentChannelNameIn
	outDataChannel chan IFmdManagerAllInstrumentChannelNameOut
}

func NewIFmdManagerAllInstrumentChannelName(waitToComplete bool) *IFmdManagerAllInstrumentChannelName {
	var outDataChannel chan IFmdManagerAllInstrumentChannelNameOut
	if waitToComplete {
		outDataChannel = make(chan IFmdManagerAllInstrumentChannelNameOut)
	} else {
		outDataChannel = nil
	}
	return &IFmdManagerAllInstrumentChannelName{
		inData:         IFmdManagerAllInstrumentChannelNameIn{},
		outDataChannel: outDataChannel,
	}
}

func (self *IFmdManagerAllInstrumentChannelName) Wait(onError func(interfaceName string, methodName string, err error) error) (IFmdManagerAllInstrumentChannelNameOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IFmdManagerAllInstrumentChannelNameError{
			InterfaceName: "IFmdManager",
			MethodName:    "AllInstrumentChannelName",
			Reason:        "Channel for IFmdManager::AllInstrumentChannelName returned false",
		}
		if onError != nil {
			err := onError("IFmdManager", "AllInstrumentChannelName", generatedError)
			return IFmdManagerAllInstrumentChannelNameOut{}, err
		} else {
			return IFmdManagerAllInstrumentChannelNameOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IFmdManagerAllInstrumentChannelName) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIFmdManagerAllInstrumentChannelName(context context.Context, channel chan<- interface{}, waitToComplete bool) (IFmdManagerAllInstrumentChannelNameOut, error) {
	if context != nil && context.Err() != nil {
		return IFmdManagerAllInstrumentChannelNameOut{}, context.Err()
	}
	data := NewIFmdManagerAllInstrumentChannelName(waitToComplete)
	if waitToComplete {
		defer func(data *IFmdManagerAllInstrumentChannelName) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IFmdManagerAllInstrumentChannelNameOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IFmdManagerAllInstrumentChannelNameOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IFmdManagerAllInstrumentChannelNameOut{}, err
	}
	return v, nil
}

// Interface IFmdManager, Method: GetInstrumentList
type IFmdManagerGetInstrumentListIn struct {
}

type IFmdManagerGetInstrumentListOut struct {
	Args0 []string
	Args1 error
}
type IFmdManagerGetInstrumentListError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IFmdManagerGetInstrumentListError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IFmdManagerGetInstrumentList struct {
	inData         IFmdManagerGetInstrumentListIn
	outDataChannel chan IFmdManagerGetInstrumentListOut
}

func NewIFmdManagerGetInstrumentList(waitToComplete bool) *IFmdManagerGetInstrumentList {
	var outDataChannel chan IFmdManagerGetInstrumentListOut
	if waitToComplete {
		outDataChannel = make(chan IFmdManagerGetInstrumentListOut)
	} else {
		outDataChannel = nil
	}
	return &IFmdManagerGetInstrumentList{
		inData:         IFmdManagerGetInstrumentListIn{},
		outDataChannel: outDataChannel,
	}
}

func (self *IFmdManagerGetInstrumentList) Wait(onError func(interfaceName string, methodName string, err error) error) (IFmdManagerGetInstrumentListOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IFmdManagerGetInstrumentListError{
			InterfaceName: "IFmdManager",
			MethodName:    "GetInstrumentList",
			Reason:        "Channel for IFmdManager::GetInstrumentList returned false",
		}
		if onError != nil {
			err := onError("IFmdManager", "GetInstrumentList", generatedError)
			return IFmdManagerGetInstrumentListOut{}, err
		} else {
			return IFmdManagerGetInstrumentListOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IFmdManagerGetInstrumentList) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIFmdManagerGetInstrumentList(context context.Context, channel chan<- interface{}, waitToComplete bool) (IFmdManagerGetInstrumentListOut, error) {
	if context != nil && context.Err() != nil {
		return IFmdManagerGetInstrumentListOut{}, context.Err()
	}
	data := NewIFmdManagerGetInstrumentList(waitToComplete)
	if waitToComplete {
		defer func(data *IFmdManagerGetInstrumentList) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IFmdManagerGetInstrumentListOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IFmdManagerGetInstrumentListOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IFmdManagerGetInstrumentListOut{}, err
	}
	return v, nil
}

// Interface IFmdManager, Method: InstrumentChannelName
type IFmdManagerInstrumentChannelNameIn struct {
	arg0 string
}

type IFmdManagerInstrumentChannelNameOut struct {
	Args0 string
	Args1 error
}
type IFmdManagerInstrumentChannelNameError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IFmdManagerInstrumentChannelNameError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IFmdManagerInstrumentChannelName struct {
	inData         IFmdManagerInstrumentChannelNameIn
	outDataChannel chan IFmdManagerInstrumentChannelNameOut
}

func NewIFmdManagerInstrumentChannelName(waitToComplete bool, arg0 string) *IFmdManagerInstrumentChannelName {
	var outDataChannel chan IFmdManagerInstrumentChannelNameOut
	if waitToComplete {
		outDataChannel = make(chan IFmdManagerInstrumentChannelNameOut)
	} else {
		outDataChannel = nil
	}
	return &IFmdManagerInstrumentChannelName{
		inData: IFmdManagerInstrumentChannelNameIn{
			arg0: arg0,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IFmdManagerInstrumentChannelName) Wait(onError func(interfaceName string, methodName string, err error) error) (IFmdManagerInstrumentChannelNameOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IFmdManagerInstrumentChannelNameError{
			InterfaceName: "IFmdManager",
			MethodName:    "InstrumentChannelName",
			Reason:        "Channel for IFmdManager::InstrumentChannelName returned false",
		}
		if onError != nil {
			err := onError("IFmdManager", "InstrumentChannelName", generatedError)
			return IFmdManagerInstrumentChannelNameOut{}, err
		} else {
			return IFmdManagerInstrumentChannelNameOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IFmdManagerInstrumentChannelName) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIFmdManagerInstrumentChannelName(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 string) (IFmdManagerInstrumentChannelNameOut, error) {
	if context != nil && context.Err() != nil {
		return IFmdManagerInstrumentChannelNameOut{}, context.Err()
	}
	data := NewIFmdManagerInstrumentChannelName(waitToComplete, arg0)
	if waitToComplete {
		defer func(data *IFmdManagerInstrumentChannelName) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IFmdManagerInstrumentChannelNameOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IFmdManagerInstrumentChannelNameOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IFmdManagerInstrumentChannelNameOut{}, err
	}
	return v, nil
}

// Interface IFmdManager, Method: InstrumentListChannelName
type IFmdManagerInstrumentListChannelNameIn struct {
}

type IFmdManagerInstrumentListChannelNameOut struct {
	Args0 string
	Args1 error
}
type IFmdManagerInstrumentListChannelNameError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IFmdManagerInstrumentListChannelNameError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IFmdManagerInstrumentListChannelName struct {
	inData         IFmdManagerInstrumentListChannelNameIn
	outDataChannel chan IFmdManagerInstrumentListChannelNameOut
}

func NewIFmdManagerInstrumentListChannelName(waitToComplete bool) *IFmdManagerInstrumentListChannelName {
	var outDataChannel chan IFmdManagerInstrumentListChannelNameOut
	if waitToComplete {
		outDataChannel = make(chan IFmdManagerInstrumentListChannelNameOut)
	} else {
		outDataChannel = nil
	}
	return &IFmdManagerInstrumentListChannelName{
		inData:         IFmdManagerInstrumentListChannelNameIn{},
		outDataChannel: outDataChannel,
	}
}

func (self *IFmdManagerInstrumentListChannelName) Wait(onError func(interfaceName string, methodName string, err error) error) (IFmdManagerInstrumentListChannelNameOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IFmdManagerInstrumentListChannelNameError{
			InterfaceName: "IFmdManager",
			MethodName:    "InstrumentListChannelName",
			Reason:        "Channel for IFmdManager::InstrumentListChannelName returned false",
		}
		if onError != nil {
			err := onError("IFmdManager", "InstrumentListChannelName", generatedError)
			return IFmdManagerInstrumentListChannelNameOut{}, err
		} else {
			return IFmdManagerInstrumentListChannelNameOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IFmdManagerInstrumentListChannelName) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIFmdManagerInstrumentListChannelName(context context.Context, channel chan<- interface{}, waitToComplete bool) (IFmdManagerInstrumentListChannelNameOut, error) {
	if context != nil && context.Err() != nil {
		return IFmdManagerInstrumentListChannelNameOut{}, context.Err()
	}
	data := NewIFmdManagerInstrumentListChannelName(waitToComplete)
	if waitToComplete {
		defer func(data *IFmdManagerInstrumentListChannelName) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IFmdManagerInstrumentListChannelNameOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IFmdManagerInstrumentListChannelNameOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IFmdManagerInstrumentListChannelNameOut{}, err
	}
	return v, nil
}

func ChannelEventsForIFmdManager(next IFmdManager, event interface{}) (bool, error) {
	switch v := event.(type) {
	case *IFmdManagerGetInstrumentList:
		data := IFmdManagerGetInstrumentListOut{}
		data.Args0, data.Args1 = next.GetInstrumentList()
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	default:
		return false, nil
	}
}
