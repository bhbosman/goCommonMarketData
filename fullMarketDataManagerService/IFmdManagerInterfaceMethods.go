// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/bhbosman/goCommonMarketData/fullMarketDataManagerService (interfaces: IFmdManager)

// Package fullMarketDataManagerService is a generated GoMock package.
package fullMarketDataManagerService

import (
	fmt "fmt"

	errors "github.com/bhbosman/gocommon/errors"
	"golang.org/x/net/context"
)

// Interface A Comment
// Interface github.com/bhbosman/goCommonMarketData/fullMarketDataManagerService
// Interface IFmdManager
// Interface IFmdManager, Method: GetInstrumentList
type IFmdManagerGetInstrumentListIn struct {
}

type IFmdManagerGetInstrumentListOut struct {
	Args0 []InstrumentStatus
	Args1 error
}
type IFmdManagerGetInstrumentListError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IFmdManagerGetInstrumentListError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IFmdManagerGetInstrumentList struct {
	inData         IFmdManagerGetInstrumentListIn
	outDataChannel chan IFmdManagerGetInstrumentListOut
}

func NewIFmdManagerGetInstrumentList(waitToComplete bool) *IFmdManagerGetInstrumentList {
	var outDataChannel chan IFmdManagerGetInstrumentListOut
	if waitToComplete {
		outDataChannel = make(chan IFmdManagerGetInstrumentListOut)
	} else {
		outDataChannel = nil
	}
	return &IFmdManagerGetInstrumentList{
		inData:         IFmdManagerGetInstrumentListIn{},
		outDataChannel: outDataChannel,
	}
}

func (self *IFmdManagerGetInstrumentList) Wait(onError func(interfaceName string, methodName string, err error) error) (IFmdManagerGetInstrumentListOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IFmdManagerGetInstrumentListError{
			InterfaceName: "IFmdManager",
			MethodName:    "GetInstrumentList",
			Reason:        "Channel for IFmdManager::GetInstrumentList returned false",
		}
		if onError != nil {
			err := onError("IFmdManager", "GetInstrumentList", generatedError)
			return IFmdManagerGetInstrumentListOut{}, err
		} else {
			return IFmdManagerGetInstrumentListOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IFmdManagerGetInstrumentList) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIFmdManagerGetInstrumentList(context context.Context, channel chan<- interface{}, waitToComplete bool) (IFmdManagerGetInstrumentListOut, error) {
	if context != nil && context.Err() != nil {
		return IFmdManagerGetInstrumentListOut{}, context.Err()
	}
	data := NewIFmdManagerGetInstrumentList(waitToComplete)
	if waitToComplete {
		defer func(data *IFmdManagerGetInstrumentList) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IFmdManagerGetInstrumentListOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IFmdManagerGetInstrumentListOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IFmdManagerGetInstrumentListOut{}, err
	}
	return v, nil
}

// Interface IFmdManager, Method: MultiSend
type IFmdManagerMultiSendIn struct {
	arg0 []interface{}
}

type IFmdManagerMultiSendOut struct {
}
type IFmdManagerMultiSendError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IFmdManagerMultiSendError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IFmdManagerMultiSend struct {
	inData         IFmdManagerMultiSendIn
	outDataChannel chan IFmdManagerMultiSendOut
}

func NewIFmdManagerMultiSend(waitToComplete bool, arg0 ...interface{}) *IFmdManagerMultiSend {
	var outDataChannel chan IFmdManagerMultiSendOut
	if waitToComplete {
		outDataChannel = make(chan IFmdManagerMultiSendOut)
	} else {
		outDataChannel = nil
	}
	return &IFmdManagerMultiSend{
		inData: IFmdManagerMultiSendIn{
			arg0: arg0,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IFmdManagerMultiSend) Wait(onError func(interfaceName string, methodName string, err error) error) (IFmdManagerMultiSendOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IFmdManagerMultiSendError{
			InterfaceName: "IFmdManager",
			MethodName:    "MultiSend",
			Reason:        "Channel for IFmdManager::MultiSend returned false",
		}
		if onError != nil {
			err := onError("IFmdManager", "MultiSend", generatedError)
			return IFmdManagerMultiSendOut{}, err
		} else {
			return IFmdManagerMultiSendOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IFmdManagerMultiSend) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIFmdManagerMultiSend(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 ...interface{}) (IFmdManagerMultiSendOut, error) {
	if context != nil && context.Err() != nil {
		return IFmdManagerMultiSendOut{}, context.Err()
	}
	data := NewIFmdManagerMultiSend(waitToComplete, arg0...)
	if waitToComplete {
		defer func(data *IFmdManagerMultiSend) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IFmdManagerMultiSendOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IFmdManagerMultiSendOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IFmdManagerMultiSendOut{}, err
	}
	return v, nil
}

// Interface IFmdManager, Method: Send
type IFmdManagerSendIn struct {
	arg0 interface{}
}

type IFmdManagerSendOut struct {
	Args0 error
}
type IFmdManagerSendError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IFmdManagerSendError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IFmdManagerSend struct {
	inData         IFmdManagerSendIn
	outDataChannel chan IFmdManagerSendOut
}

func NewIFmdManagerSend(waitToComplete bool, arg0 interface{}) *IFmdManagerSend {
	var outDataChannel chan IFmdManagerSendOut
	if waitToComplete {
		outDataChannel = make(chan IFmdManagerSendOut)
	} else {
		outDataChannel = nil
	}
	return &IFmdManagerSend{
		inData: IFmdManagerSendIn{
			arg0: arg0,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IFmdManagerSend) Wait(onError func(interfaceName string, methodName string, err error) error) (IFmdManagerSendOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IFmdManagerSendError{
			InterfaceName: "IFmdManager",
			MethodName:    "Send",
			Reason:        "Channel for IFmdManager::Send returned false",
		}
		if onError != nil {
			err := onError("IFmdManager", "Send", generatedError)
			return IFmdManagerSendOut{}, err
		} else {
			return IFmdManagerSendOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IFmdManagerSend) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIFmdManagerSend(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 interface{}) (IFmdManagerSendOut, error) {
	if context != nil && context.Err() != nil {
		return IFmdManagerSendOut{}, context.Err()
	}
	data := NewIFmdManagerSend(waitToComplete, arg0)
	if waitToComplete {
		defer func(data *IFmdManagerSend) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IFmdManagerSendOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IFmdManagerSendOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IFmdManagerSendOut{}, err
	}
	return v, nil
}

// Interface IFmdManager, Method: SubscribeFullMarketData
type IFmdManagerSubscribeFullMarketDataIn struct {
	arg0 string
	arg1 string
}

type IFmdManagerSubscribeFullMarketDataOut struct {
}
type IFmdManagerSubscribeFullMarketDataError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IFmdManagerSubscribeFullMarketDataError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IFmdManagerSubscribeFullMarketData struct {
	inData         IFmdManagerSubscribeFullMarketDataIn
	outDataChannel chan IFmdManagerSubscribeFullMarketDataOut
}

func NewIFmdManagerSubscribeFullMarketData(waitToComplete bool, arg0, arg1 string) *IFmdManagerSubscribeFullMarketData {
	var outDataChannel chan IFmdManagerSubscribeFullMarketDataOut
	if waitToComplete {
		outDataChannel = make(chan IFmdManagerSubscribeFullMarketDataOut)
	} else {
		outDataChannel = nil
	}
	return &IFmdManagerSubscribeFullMarketData{
		inData: IFmdManagerSubscribeFullMarketDataIn{
			arg0: arg0,
			arg1: arg1,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IFmdManagerSubscribeFullMarketData) Wait(onError func(interfaceName string, methodName string, err error) error) (IFmdManagerSubscribeFullMarketDataOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IFmdManagerSubscribeFullMarketDataError{
			InterfaceName: "IFmdManager",
			MethodName:    "SubscribeFullMarketData",
			Reason:        "Channel for IFmdManager::SubscribeFullMarketData returned false",
		}
		if onError != nil {
			err := onError("IFmdManager", "SubscribeFullMarketData", generatedError)
			return IFmdManagerSubscribeFullMarketDataOut{}, err
		} else {
			return IFmdManagerSubscribeFullMarketDataOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IFmdManagerSubscribeFullMarketData) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIFmdManagerSubscribeFullMarketData(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0, arg1 string) (IFmdManagerSubscribeFullMarketDataOut, error) {
	if context != nil && context.Err() != nil {
		return IFmdManagerSubscribeFullMarketDataOut{}, context.Err()
	}
	data := NewIFmdManagerSubscribeFullMarketData(waitToComplete, arg0, arg1)
	if waitToComplete {
		defer func(data *IFmdManagerSubscribeFullMarketData) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IFmdManagerSubscribeFullMarketDataOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IFmdManagerSubscribeFullMarketDataOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IFmdManagerSubscribeFullMarketDataOut{}, err
	}
	return v, nil
}

// Interface IFmdManager, Method: SubscribeFullMarketDataMulti
type IFmdManagerSubscribeFullMarketDataMultiIn struct {
	arg0 string
	arg1 []string
}

type IFmdManagerSubscribeFullMarketDataMultiOut struct {
}
type IFmdManagerSubscribeFullMarketDataMultiError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IFmdManagerSubscribeFullMarketDataMultiError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IFmdManagerSubscribeFullMarketDataMulti struct {
	inData         IFmdManagerSubscribeFullMarketDataMultiIn
	outDataChannel chan IFmdManagerSubscribeFullMarketDataMultiOut
}

func NewIFmdManagerSubscribeFullMarketDataMulti(waitToComplete bool, arg0 string, arg1 ...string) *IFmdManagerSubscribeFullMarketDataMulti {
	var outDataChannel chan IFmdManagerSubscribeFullMarketDataMultiOut
	if waitToComplete {
		outDataChannel = make(chan IFmdManagerSubscribeFullMarketDataMultiOut)
	} else {
		outDataChannel = nil
	}
	return &IFmdManagerSubscribeFullMarketDataMulti{
		inData: IFmdManagerSubscribeFullMarketDataMultiIn{
			arg0: arg0,
			arg1: arg1,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IFmdManagerSubscribeFullMarketDataMulti) Wait(onError func(interfaceName string, methodName string, err error) error) (IFmdManagerSubscribeFullMarketDataMultiOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IFmdManagerSubscribeFullMarketDataMultiError{
			InterfaceName: "IFmdManager",
			MethodName:    "SubscribeFullMarketDataMulti",
			Reason:        "Channel for IFmdManager::SubscribeFullMarketDataMulti returned false",
		}
		if onError != nil {
			err := onError("IFmdManager", "SubscribeFullMarketDataMulti", generatedError)
			return IFmdManagerSubscribeFullMarketDataMultiOut{}, err
		} else {
			return IFmdManagerSubscribeFullMarketDataMultiOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IFmdManagerSubscribeFullMarketDataMulti) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIFmdManagerSubscribeFullMarketDataMulti(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 string, arg1 ...string) (IFmdManagerSubscribeFullMarketDataMultiOut, error) {
	if context != nil && context.Err() != nil {
		return IFmdManagerSubscribeFullMarketDataMultiOut{}, context.Err()
	}
	data := NewIFmdManagerSubscribeFullMarketDataMulti(waitToComplete, arg0, arg1...)
	if waitToComplete {
		defer func(data *IFmdManagerSubscribeFullMarketDataMulti) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IFmdManagerSubscribeFullMarketDataMultiOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IFmdManagerSubscribeFullMarketDataMultiOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IFmdManagerSubscribeFullMarketDataMultiOut{}, err
	}
	return v, nil
}

// Interface IFmdManager, Method: UnsubscribeFullMarketData
type IFmdManagerUnsubscribeFullMarketDataIn struct {
	arg0 string
	arg1 string
}

type IFmdManagerUnsubscribeFullMarketDataOut struct {
}
type IFmdManagerUnsubscribeFullMarketDataError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IFmdManagerUnsubscribeFullMarketDataError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IFmdManagerUnsubscribeFullMarketData struct {
	inData         IFmdManagerUnsubscribeFullMarketDataIn
	outDataChannel chan IFmdManagerUnsubscribeFullMarketDataOut
}

func NewIFmdManagerUnsubscribeFullMarketData(waitToComplete bool, arg0, arg1 string) *IFmdManagerUnsubscribeFullMarketData {
	var outDataChannel chan IFmdManagerUnsubscribeFullMarketDataOut
	if waitToComplete {
		outDataChannel = make(chan IFmdManagerUnsubscribeFullMarketDataOut)
	} else {
		outDataChannel = nil
	}
	return &IFmdManagerUnsubscribeFullMarketData{
		inData: IFmdManagerUnsubscribeFullMarketDataIn{
			arg0: arg0,
			arg1: arg1,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IFmdManagerUnsubscribeFullMarketData) Wait(onError func(interfaceName string, methodName string, err error) error) (IFmdManagerUnsubscribeFullMarketDataOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IFmdManagerUnsubscribeFullMarketDataError{
			InterfaceName: "IFmdManager",
			MethodName:    "UnsubscribeFullMarketData",
			Reason:        "Channel for IFmdManager::UnsubscribeFullMarketData returned false",
		}
		if onError != nil {
			err := onError("IFmdManager", "UnsubscribeFullMarketData", generatedError)
			return IFmdManagerUnsubscribeFullMarketDataOut{}, err
		} else {
			return IFmdManagerUnsubscribeFullMarketDataOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IFmdManagerUnsubscribeFullMarketData) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIFmdManagerUnsubscribeFullMarketData(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0, arg1 string) (IFmdManagerUnsubscribeFullMarketDataOut, error) {
	if context != nil && context.Err() != nil {
		return IFmdManagerUnsubscribeFullMarketDataOut{}, context.Err()
	}
	data := NewIFmdManagerUnsubscribeFullMarketData(waitToComplete, arg0, arg1)
	if waitToComplete {
		defer func(data *IFmdManagerUnsubscribeFullMarketData) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IFmdManagerUnsubscribeFullMarketDataOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IFmdManagerUnsubscribeFullMarketDataOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IFmdManagerUnsubscribeFullMarketDataOut{}, err
	}
	return v, nil
}

// Interface IFmdManager, Method: UnsubscribeFullMarketDataMulti
type IFmdManagerUnsubscribeFullMarketDataMultiIn struct {
	arg0 string
	arg1 []string
}

type IFmdManagerUnsubscribeFullMarketDataMultiOut struct {
}
type IFmdManagerUnsubscribeFullMarketDataMultiError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IFmdManagerUnsubscribeFullMarketDataMultiError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IFmdManagerUnsubscribeFullMarketDataMulti struct {
	inData         IFmdManagerUnsubscribeFullMarketDataMultiIn
	outDataChannel chan IFmdManagerUnsubscribeFullMarketDataMultiOut
}

func NewIFmdManagerUnsubscribeFullMarketDataMulti(waitToComplete bool, arg0 string, arg1 ...string) *IFmdManagerUnsubscribeFullMarketDataMulti {
	var outDataChannel chan IFmdManagerUnsubscribeFullMarketDataMultiOut
	if waitToComplete {
		outDataChannel = make(chan IFmdManagerUnsubscribeFullMarketDataMultiOut)
	} else {
		outDataChannel = nil
	}
	return &IFmdManagerUnsubscribeFullMarketDataMulti{
		inData: IFmdManagerUnsubscribeFullMarketDataMultiIn{
			arg0: arg0,
			arg1: arg1,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IFmdManagerUnsubscribeFullMarketDataMulti) Wait(onError func(interfaceName string, methodName string, err error) error) (IFmdManagerUnsubscribeFullMarketDataMultiOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IFmdManagerUnsubscribeFullMarketDataMultiError{
			InterfaceName: "IFmdManager",
			MethodName:    "UnsubscribeFullMarketDataMulti",
			Reason:        "Channel for IFmdManager::UnsubscribeFullMarketDataMulti returned false",
		}
		if onError != nil {
			err := onError("IFmdManager", "UnsubscribeFullMarketDataMulti", generatedError)
			return IFmdManagerUnsubscribeFullMarketDataMultiOut{}, err
		} else {
			return IFmdManagerUnsubscribeFullMarketDataMultiOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IFmdManagerUnsubscribeFullMarketDataMulti) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIFmdManagerUnsubscribeFullMarketDataMulti(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 string, arg1 ...string) (IFmdManagerUnsubscribeFullMarketDataMultiOut, error) {
	if context != nil && context.Err() != nil {
		return IFmdManagerUnsubscribeFullMarketDataMultiOut{}, context.Err()
	}
	data := NewIFmdManagerUnsubscribeFullMarketDataMulti(waitToComplete, arg0, arg1...)
	if waitToComplete {
		defer func(data *IFmdManagerUnsubscribeFullMarketDataMulti) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IFmdManagerUnsubscribeFullMarketDataMultiOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IFmdManagerUnsubscribeFullMarketDataMultiOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IFmdManagerUnsubscribeFullMarketDataMultiOut{}, err
	}
	return v, nil
}

func ChannelEventsForIFmdManager(next IFmdManager, event interface{}) (bool, error) {
	switch v := event.(type) {
	case *IFmdManagerGetInstrumentList:
		data := IFmdManagerGetInstrumentListOut{}
		data.Args0, data.Args1 = next.GetInstrumentList()
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IFmdManagerMultiSend:
		data := IFmdManagerMultiSendOut{}
		next.MultiSend(v.inData.arg0...)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IFmdManagerSend:
		data := IFmdManagerSendOut{}
		data.Args0 = next.Send(v.inData.arg0)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IFmdManagerSubscribeFullMarketData:
		data := IFmdManagerSubscribeFullMarketDataOut{}
		next.SubscribeFullMarketData(v.inData.arg0, v.inData.arg1)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IFmdManagerSubscribeFullMarketDataMulti:
		data := IFmdManagerSubscribeFullMarketDataMultiOut{}
		next.SubscribeFullMarketDataMulti(v.inData.arg0, v.inData.arg1...)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IFmdManagerUnsubscribeFullMarketData:
		data := IFmdManagerUnsubscribeFullMarketDataOut{}
		next.UnsubscribeFullMarketData(v.inData.arg0, v.inData.arg1)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IFmdManagerUnsubscribeFullMarketDataMulti:
		data := IFmdManagerUnsubscribeFullMarketDataMultiOut{}
		next.UnsubscribeFullMarketDataMulti(v.inData.arg0, v.inData.arg1...)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	default:
		return false, nil
	}
}
